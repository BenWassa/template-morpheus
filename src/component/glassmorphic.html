<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React Bits - Glass Surface PoC</title>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS (used only for layout in App, not component) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Font -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap"
      rel="stylesheet"
    />

    <style>
      :root {
        color-scheme: light dark;
      }

      body {
        font-family: 'Inter', sans-serif;
        margin: 0;
        padding: 0;
        background-color: #111;
        overflow-x: hidden;
        min-height: 100vh;
      }

      /* --- YOUR PROVIDED CSS START --- */
      .glass-surface {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        transition: opacity 0.26s ease-out;
      }

      .glass-surface__filter {
        width: 100%;
        height: 100%;
        pointer-events: none;
        position: absolute;
        inset: 0;
        opacity: 0;
        z-index: -1;
      }

      .glass-surface__content {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0.5rem;
        border-radius: inherit;
        position: relative;
        z-index: 1;
      }

      .glass-surface--svg {
        /* Using fallback for light-dark() compatibility if needed, but standard browsers support it */
        background: light-dark(
          hsl(0 0% 100% / var(--glass-frost, 0)),
          hsl(0 0% 0% / var(--glass-frost, 0))
        );
        backdrop-filter: var(--filter-id, url(#glass-filter)) saturate(var(--glass-saturation, 1));
        box-shadow:
          0 0 2px 1px
            light-dark(
              color-mix(in oklch, black, transparent 85%),
              color-mix(in oklch, white, transparent 65%)
            )
            inset,
          0 0 10px 4px
            light-dark(
              color-mix(in oklch, black, transparent 90%),
              color-mix(in oklch, white, transparent 85%)
            )
            inset,
          0px 4px 16px rgba(17, 17, 26, 0.05),
          0px 8px 24px rgba(17, 17, 26, 0.05),
          0px 16px 56px rgba(17, 17, 26, 0.05),
          0px 4px 16px rgba(17, 17, 26, 0.05) inset,
          0px 8px 24px rgba(17, 17, 26, 0.05) inset,
          0px 16px 56px rgba(17, 17, 26, 0.05) inset;
      }

      .glass-surface--fallback {
        background: rgba(255, 255, 255, 0.25);
        backdrop-filter: blur(12px) saturate(1.8) brightness(1.1);
        -webkit-backdrop-filter: blur(12px) saturate(1.8) brightness(1.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        box-shadow:
          0 8px 32px 0 rgba(31, 38, 135, 0.2),
          0 2px 16px 0 rgba(31, 38, 135, 0.1),
          inset 0 1px 0 0 rgba(255, 255, 255, 0.4),
          inset 0 -1px 0 0 rgba(255, 255, 255, 0.2);
      }

      @media (prefers-color-scheme: dark) {
        .glass-surface--fallback {
          background: rgba(255, 255, 255, 0.1);
          backdrop-filter: blur(12px) saturate(1.8) brightness(1.2);
          -webkit-backdrop-filter: blur(12px) saturate(1.8) brightness(1.2);
          border: 1px solid rgba(255, 255, 255, 0.2);
          box-shadow:
            inset 0 1px 0 0 rgba(255, 255, 255, 0.2),
            inset 0 -1px 0 0 rgba(255, 255, 255, 0.1);
        }
      }

      @supports not (backdrop-filter: blur(10px)) {
        .glass-surface--fallback {
          background: rgba(255, 255, 255, 0.4);
          box-shadow:
            inset 0 1px 0 0 rgba(255, 255, 255, 0.5),
            inset 0 -1px 0 0 rgba(255, 255, 255, 0.3);
        }

        .glass-surface--fallback::before {
          content: '';
          position: absolute;
          inset: 0;
          background: rgba(255, 255, 255, 0.15);
          border-radius: inherit;
          z-index: -1;
        }
      }

      @supports not (backdrop-filter: blur(10px)) {
        @media (prefers-color-scheme: dark) {
          .glass-surface--fallback {
            background: rgba(0, 0, 0, 0.4);
          }

          .glass-surface--fallback::before {
            background: rgba(255, 255, 255, 0.05);
          }
        }
      }

      .glass-surface:focus-visible {
        outline: 2px solid light-dark(#007aff, #0a84ff);
        outline-offset: 2px;
      }
      /* --- YOUR PROVIDED CSS END --- */
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef, useId } = React;

      // --- provided GlassSurface Component ---
      const GlassSurface = ({
        children,
        width = 200,
        height = 80,
        borderRadius = 20,
        borderWidth = 0.07,
        brightness = 50,
        opacity = 0.93,
        blur = 11,
        displace = 0,
        backgroundOpacity = 0,
        saturation = 1,
        distortionScale = -180,
        redOffset = 0,
        greenOffset = 10,
        blueOffset = 20,
        xChannel = 'R',
        yChannel = 'G',
        mixBlendMode = 'difference',
        className = '',
        style = {},
      }) => {
        const uniqueId = useId().replace(/:/g, '-');
        const filterId = `glass-filter-${uniqueId}`;
        const redGradId = `red-grad-${uniqueId}`;
        const blueGradId = `blue-grad-${uniqueId}`;

        const [svgSupported, setSvgSupported] = useState(false);

        const containerRef = useRef(null);
        const feImageRef = useRef(null);
        const redChannelRef = useRef(null);
        const greenChannelRef = useRef(null);
        const blueChannelRef = useRef(null);
        const gaussianBlurRef = useRef(null);

        const generateDisplacementMap = () => {
          const rect = containerRef.current?.getBoundingClientRect();
          const actualWidth = rect?.width || 400;
          const actualHeight = rect?.height || 200;
          const edgeSize = Math.min(actualWidth, actualHeight) * (borderWidth * 0.5);

          // Note: In strict React without raw-loader, we insert the SVG as a data URI
          const svgContent = `
              <svg viewBox="0 0 ${actualWidth} ${actualHeight}" xmlns="http://www.w3.org/2000/svg">
                <defs>
                  <linearGradient id="${redGradId}" x1="100%" y1="0%" x2="0%" y2="0%">
                    <stop offset="0%" stop-color="#0000"/>
                    <stop offset="100%" stop-color="red"/>
                  </linearGradient>
                  <linearGradient id="${blueGradId}" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" stop-color="#0000"/>
                    <stop offset="100%" stop-color="blue"/>
                  </linearGradient>
                </defs>
                <rect x="0" y="0" width="${actualWidth}" height="${actualHeight}" fill="black"></rect>
                <rect x="0" y="0" width="${actualWidth}" height="${actualHeight}" rx="${borderRadius}" fill="url(#${redGradId})" />
                <rect x="0" y="0" width="${actualWidth}" height="${actualHeight}" rx="${borderRadius}" fill="url(#${blueGradId})" style="mix-blend-mode: ${mixBlendMode}" />
                <rect x="${edgeSize}" y="${edgeSize}" width="${actualWidth - edgeSize * 2}" height="${actualHeight - edgeSize * 2}" rx="${borderRadius}" fill="hsl(0 0% ${brightness}% / ${opacity})" style="filter:blur(${blur}px)" />
              </svg>
            `;

          return `data:image/svg+xml,${encodeURIComponent(svgContent)}`;
        };

        const updateDisplacementMap = () => {
          if (feImageRef.current) {
            feImageRef.current.setAttribute('href', generateDisplacementMap());
          }
        };

        useEffect(() => {
          updateDisplacementMap();
          [
            { ref: redChannelRef, offset: redOffset },
            { ref: greenChannelRef, offset: greenOffset },
            { ref: blueChannelRef, offset: blueOffset },
          ].forEach(({ ref, offset }) => {
            if (ref.current) {
              ref.current.setAttribute('scale', (distortionScale + offset).toString());
              ref.current.setAttribute('xChannelSelector', xChannel);
              ref.current.setAttribute('yChannelSelector', yChannel);
            }
          });

          if (gaussianBlurRef.current) {
            gaussianBlurRef.current.setAttribute('stdDeviation', displace.toString());
          }
        }, [
          width,
          height,
          borderRadius,
          borderWidth,
          brightness,
          opacity,
          blur,
          displace,
          distortionScale,
          redOffset,
          greenOffset,
          blueOffset,
          xChannel,
          yChannel,
          mixBlendMode,
        ]);

        useEffect(() => {
          if (!containerRef.current) return;
          const resizeObserver = new ResizeObserver(() => {
            setTimeout(updateDisplacementMap, 0);
          });
          resizeObserver.observe(containerRef.current);
          return () => {
            resizeObserver.disconnect();
          };
        }, []);

        useEffect(() => {
          setTimeout(updateDisplacementMap, 0);
        }, [width, height]);

        useEffect(() => {
          setSvgSupported(supportsSVGFilters());
        }, []);

        const supportsSVGFilters = () => {
          if (typeof window === 'undefined' || typeof document === 'undefined') {
            return false;
          }
          const isWebkit =
            /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
          const isFirefox = /Firefox/.test(navigator.userAgent);

          // Note: The original logic disables SVG filters for Webkit/Firefox due to potential bugs
          // You can remove this check if you want to force it on those browsers
          if (isWebkit || isFirefox) {
            return false;
          }

          const div = document.createElement('div');
          div.style.backdropFilter = `url(#${filterId})`;
          return div.style.backdropFilter !== '';
        };

        const containerStyle = {
          ...style,
          width: typeof width === 'number' ? `${width}px` : width,
          height: typeof height === 'number' ? `${height}px` : height,
          borderRadius: `${borderRadius}px`,
          '--glass-frost': backgroundOpacity,
          '--glass-saturation': saturation,
          '--filter-id': `url(#${filterId})`,
        };

        return (
          <div
            ref={containerRef}
            className={`glass-surface ${svgSupported ? 'glass-surface--svg' : 'glass-surface--fallback'} ${className}`}
            style={containerStyle}
          >
            <svg className="glass-surface__filter" xmlns="http://www.w3.org/2000/svg">
              <defs>
                <filter
                  id={filterId}
                  colorInterpolationFilters="sRGB"
                  x="0%"
                  y="0%"
                  width="100%"
                  height="100%"
                >
                  <feImage
                    ref={feImageRef}
                    x="0"
                    y="0"
                    width="100%"
                    height="100%"
                    preserveAspectRatio="none"
                    result="map"
                  />

                  <feDisplacementMap
                    ref={redChannelRef}
                    in="SourceGraphic"
                    in2="map"
                    id="redchannel"
                    result="dispRed"
                  />
                  <feColorMatrix
                    in="dispRed"
                    type="matrix"
                    values="1 0 0 0 0
                              0 0 0 0 0
                              0 0 0 0 0
                              0 0 0 1 0"
                    result="red"
                  />

                  <feDisplacementMap
                    ref={greenChannelRef}
                    in="SourceGraphic"
                    in2="map"
                    id="greenchannel"
                    result="dispGreen"
                  />
                  <feColorMatrix
                    in="dispGreen"
                    type="matrix"
                    values="0 0 0 0 0
                              0 1 0 0 0
                              0 0 0 0 0
                              0 0 0 1 0"
                    result="green"
                  />

                  <feDisplacementMap
                    ref={blueChannelRef}
                    in="SourceGraphic"
                    in2="map"
                    id="bluechannel"
                    result="dispBlue"
                  />
                  <feColorMatrix
                    in="dispBlue"
                    type="matrix"
                    values="0 0 0 0 0
                              0 0 0 0 0
                              0 0 1 0 0
                              0 0 0 1 0"
                    result="blue"
                  />

                  <feBlend in="red" in2="green" mode="screen" result="rg" />
                  <feBlend in="rg" in2="blue" mode="screen" result="output" />
                  <feGaussianBlur ref={gaussianBlurRef} in="output" stdDeviation="0.7" />
                </filter>
              </defs>
            </svg>

            <div className="glass-surface__content">{children}</div>
          </div>
        );
      };

      const App = () => {
        return (
          <div className="min-h-screen w-full bg-neutral-900 text-white p-8 pb-16 space-y-12">
            <header className="text-center space-y-2 mb-8">
              <h1 className="text-4xl font-bold">Glass Surface</h1>
              <p className="text-gray-400">Proof of Concept over Real Imagery</p>
            </header>

            {/* Scenario 1: City Lights - Great for Refraction */}
            <div className="space-y-4 max-w-4xl mx-auto">
              <h3 className="text-sm font-semibold uppercase tracking-wider text-gray-500 ml-2">
                High Contrast Background
              </h3>
              <section className="relative w-full rounded-3xl overflow-hidden h-[400px] flex items-center justify-center shadow-2xl border border-white/10 group">
                {/* Background Image: Tokyo Night */}
                <img
                  src="https://images.unsplash.com/photo-1540959733332-eab4deabeeaf?q=80&w=2094&auto=format&fit=crop"
                  alt="City Background"
                  className="absolute inset-0 w-full h-full object-cover transition-transform duration-[20s] ease-linear group-hover:scale-110"
                />
                <div className="absolute inset-0 bg-black/10"></div>

                {/* Standard Usage */}
                <GlassSurface
                  width={300}
                  height={200}
                  borderRadius={24}
                  className="shadow-2xl hover:scale-105 transition-transform duration-300"
                >
                  <h2 className="text-3xl font-bold text-white tracking-tight drop-shadow-md">
                    Night City
                  </h2>
                </GlassSurface>
              </section>
            </div>

            {/* Scenario 2: Abstract Texture - Great for Chromatic Aberration */}
            <div className="space-y-4 max-w-4xl mx-auto">
              <h3 className="text-sm font-semibold uppercase tracking-wider text-gray-500 ml-2">
                Textured Background
              </h3>
              <section className="relative w-full rounded-3xl overflow-hidden h-[400px] flex items-center justify-center shadow-2xl border border-white/10 group">
                {/* Background Image: Abstract Fluid */}
                <img
                  src="https://images.unsplash.com/photo-1618005182384-a83a8bd57fbe?q=80&w=2064&auto=format&fit=crop"
                  alt="Abstract Background"
                  className="absolute inset-0 w-full h-full object-cover transition-transform duration-[20s] ease-linear group-hover:scale-110"
                />

                {/* Exact Config Usage (Wide Pill) */}
                <GlassSurface
                  width={500}
                  height={120}
                  borderRadius={50}
                  backgroundOpacity={0.1}
                  saturation={1}
                  borderWidth={0.07}
                  brightness={50}
                  opacity={0.93}
                  blur={11}
                  displace={0.5}
                  distortionScale={-180}
                  redOffset={0}
                  greenOffset={10}
                  blueOffset={20}
                  className="shadow-2xl hover:scale-105 transition-transform duration-300"
                >
                  <div className="flex items-center gap-8 px-10 w-full justify-between">
                    <div className="flex flex-col">
                      <span className="text-xs uppercase tracking-widest text-white/60 font-bold mb-1">
                        Project
                      </span>
                      <span className="text-3xl font-bold text-white drop-shadow-sm">Aurora</span>
                    </div>
                    <div className="text-right">
                      <span className="inline-flex items-center rounded-full bg-green-400/20 px-3 py-1 text-xs font-medium text-green-300 ring-1 ring-inset ring-green-400/30 backdrop-blur-sm">
                        Active
                      </span>
                    </div>
                  </div>
                </GlassSurface>
              </section>
            </div>

            <footer className="text-center text-gray-500 text-xs max-w-md mx-auto pt-8">
              Images via Unsplash. Note: Use Chrome/Edge for full SVG displacement effects.
            </footer>
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>
